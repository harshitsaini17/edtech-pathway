<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Advanced Dynamic Markdown Statistics Viewer</title>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<style>
  :root {
    --primary-blue: #0c3c60;
    --accent-blue: #1e90ff;
    --light-bg: #f4f7f8;
    --formula-bg: #f0f7ff;
    --example-bg: #f9f9f9;
    --warning-bg: #fff4e5;
    --warning-color: #ffa726;
  }

  * { box-sizing: border-box; }
  
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    margin: 0; padding: 20px; max-width: 1000px; margin: 0 auto;
    background: var(--light-bg); color: #333; line-height: 1.6;
  }

  .input-section {
    margin-bottom: 30px; background: white; padding: 20px;
    border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);
  }

  #markdownInput {
    width: 100%; height: 200px; padding: 15px;
    font-family: 'Courier New', Monaco, monospace;
    font-size: 14px; border: 2px solid #ddd;
    border-radius: 5px; resize: vertical;
  }

  #renderButton {
    background: var(--accent-blue); color: white;
    border: none; padding: 12px 25px; border-radius: 5px;
    font-size: 16px; cursor: pointer; margin-top: 10px;
    transition: background 0.3s ease;
  }

  #renderButton:hover {
    background: #0066cc;
  }

  #output {
    background: white; padding: 25px; border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1); min-height: 200px;
  }

  /* Typography */
  h1, h2, h3, h4, h5, h6 {
    color: var(--primary-blue); margin-top: 2em; margin-bottom: 0.5em;
    font-weight: 600; line-height: 1.3;
  }
  h1 { border-bottom: 3px solid var(--accent-blue); padding-bottom: 10px; }
  h2 { border-bottom: 1px solid #ddd; padding-bottom: 5px; }

  /* Lists */
  ul, ol { padding-left: 25px; margin: 15px 0; }
  li { margin: 8px 0; }

  /* Tables */
  .markdown-table {
    width: 100%; border-collapse: collapse; margin: 20px 0;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1); border-radius: 5px;
    overflow: hidden;
  }
  .markdown-table th {
    background: var(--primary-blue); color: white;
    padding: 12px 15px; text-align: left; font-weight: 600;
  }
  .markdown-table td {
    padding: 12px 15px; border-bottom: 1px solid #eee;
  }
  .markdown-table tr:hover {
    background: #f8f9fa;
  }
  .markdown-table tr:last-child td {
    border-bottom: none;
  }

  /* Formulas */
  .formula-display {
    background: var(--formula-bg); border-left: 5px solid var(--accent-blue);
    padding: 20px; margin: 20px 0; border-radius: 0 5px 5px 0;
    font-size: 1.2em; text-align: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
  }
  .formula-inline {
    background: var(--formula-bg); padding: 3px 6px;
    border-radius: 3px; font-weight: 500;
  }

  /* Code blocks */
  pre {
    background: #f8f8f8; padding: 20px; border-radius: 5px;
    overflow-x: auto; border: 1px solid #e1e1e1;
    font-family: 'Courier New', Monaco, monospace;
  }
  code {
    background: #f1f1f1; padding: 2px 5px; border-radius: 3px;
    font-family: 'Courier New', Monaco, monospace; color: #d63384;
  }

  /* Special sections */
  .example-section {
    background: var(--example-bg); border-left: 5px solid #28a745;
    padding: 20px; margin: 20px 0; border-radius: 0 5px 5px 0;
  }
  .warning-section {
    background: var(--warning-bg); border-left: 5px solid var(--warning-color);
    padding: 20px; margin: 20px 0; border-radius: 0 5px 5px 0;
  }

  blockquote {
    border-left: 4px solid var(--accent-blue); padding-left: 20px;
    margin: 20px 0; font-style: italic; color: #666;
    background: #f0f4ff; padding: 15px 15px 15px 35px;
    border-radius: 0 5px 5px 0;
  }

  /* Responsive */
  @media (max-width: 768px) {
    body { padding: 10px; }
    .input-section, #output { padding: 15px; }
    .markdown-table { font-size: 14px; }
    .markdown-table th, .markdown-table td { padding: 8px 10px; }
  }
</style>
</head>
<body>

<div class="input-section">
  <h1>üìä Advanced Markdown Statistics Viewer</h1>
  <p>Paste your markdown content with LaTeX formulas and tables below:</p>
  
  <textarea id="markdownInput" placeholder="# Sample Content

## Data Types
- **Nominal**: Categories with no order
- **Ordinal**: Ordered categories

### Mean Formula
The sample mean is:
\[ \bar{X} = \frac{1}{n}\sum_{i=1}^n X_i \]

| Variable | Type | Example |
|----------|------|---------|
| Color | Nominal | Red, Blue |
| Rating | Ordinal | 1-5 scale |

**Why?** It minimizes squared deviations.

> **Important**: Always check data type before analysis.

### Example Calculation
For data: 2, 4, 6, 8, 10
Mean = \( \frac{2+4+6+8+10}{5} = 6 \)"></textarea>
  
  <button id="renderButton">üöÄ Render Content</button>
</div>

<div id="output">
  <p><em>Your rendered content will appear here...</em></p>
</div>

<script>
class MarkdownProcessor {
  constructor() {
    this.formulaCounter = 0;
  }

  // Main processing function
  process(markdown) {
    let html = markdown;
    
    // Process in order: formulas first (to protect them), then other elements
    html = this.processDisplayFormulas(html);
    html = this.processInlineFormulas(html);
    html = this.processTables(html);
    html = this.processHeaders(html);
    html = this.processLists(html);
    html = this.processBlockquotes(html);
    html = this.processCodeBlocks(html);
    html = this.processInlineCode(html);
    html = this.processBold(html);
    html = this.processItalic(html);
    html = this.processSpecialSections(html);
    html = this.processParagraphs(html);
    
    return html;
  }

  // Process display formulas \[ ... \]
  processDisplayFormulas(text) {
    return text.replace(/\\\[([\s\S]*?)\\\]/g, (match, formula) => {
      return `<div class="formula-display">\\[${formula}\\]</div>`;
    });
  }

  // Process inline formulas \( ... \)
  processInlineFormulas(text) {
    return text.replace(/\\\(([\s\S]*?)\\\)/g, (match, formula) => {
      return `<span class="formula-inline">\\(${formula}\\)</span>`;
    });
  }

  // Process markdown tables
  processTables(text) {
    const tableRegex = /\|(.+)\|\s*\n\|[-:\s\|]+\|\s*\n((?:\|.+\|\s*\n)*)/gm;
    
    return text.replace(tableRegex, (match, header, rows) => {
      const headerCells = header.split('|')
        .map(cell => cell.trim())
        .filter(cell => cell)
        .map(cell => `<th>${cell}</th>`)
        .join('');
      
      const rowHtml = rows.trim().split('\n')
        .map(row => {
          const cells = row.split('|')
            .map(cell => cell.trim())
            .filter(cell => cell)
            .map(cell => `<td>${cell}</td>`)
            .join('');
          return `<tr>${cells}</tr>`;
        })
        .join('');
      
      return `<table class="markdown-table">
        <thead><tr>${headerCells}</tr></thead>
        <tbody>${rowHtml}</tbody>
      </table>`;
    });
  }

  // Process headers
  processHeaders(text) {
    return text
      .replace(/^### (.+)$/gm, '<h3>$1</h3>')
      .replace(/^## (.+)$/gm, '<h2>$1</h2>')
      .replace(/^# (.+)$/gm, '<h1>$1</h1>')
      .replace(/^#### (.+)$/gm, '<h4>$1</h4>')
      .replace(/^##### (.+)$/gm, '<h5>$1</h5>');
  }

  // Process lists
  processLists(text) {
    // Unordered lists
    text = text.replace(/^- (.+)$/gm, '<li>$1</li>');
    text = text.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');
    
    // Ordered lists
    text = text.replace(/^\d+\. (.+)$/gm, '<li>$1</li>');
    
    return text;
  }

  // Process blockquotes
  processBlockquotes(text) {
    return text.replace(/^> (.+)$/gm, '<blockquote>$1</blockquote>');
  }

  // Process code blocks
  processCodeBlocks(text) {
    return text.replace(/``````/g, '<pre><code>$1</code></pre>');
  }

  // Process inline code
  processInlineCode(text) {
    return text.replace(/`([^`]+)`/g, '<code>$1</code>');
  }

  // Process bold text
  processBold(text) {
    return text.replace(/\*\*([^\*]+)\*\*/g, '<strong>$1</strong>');
  }

  // Process italic text
  processItalic(text) {
    return text.replace(/\*([^\*]+)\*/g, '<em>$1</em>');
  }

  // Process special sections
  processSpecialSections(text) {
    // Example sections
    text = text.replace(/^### Example(.*)$/gm, '<div class="example-section"><h3>üìù Example$1</h3>');
    text = text.replace(/^‚ö†Ô∏è(.*)$/gm, '<div class="warning-section"><strong>‚ö†Ô∏è$1</strong>');
    
    return text;
  }

  // Process paragraphs (convert double newlines to paragraphs)
  processParagraphs(text) {
    const paragraphs = text.split(/\n\s*\n/);
    return paragraphs.map(p => {
      p = p.trim();
      if (p && !p.startsWith('<')) {
        return `<p>${p}</p>`;
      }
      return p;
    }).join('\n\n');
  }
}

// Initialize the application
document.addEventListener('DOMContentLoaded', function() {
  const processor = new MarkdownProcessor();
  const input = document.getElementById('markdownInput');
  const output = document.getElementById('output');
  const button = document.getElementById('renderButton');

  button.addEventListener('click', function() {
    const markdown = input.value;
    if (!markdown.trim()) {
      output.innerHTML = '<p><em>Please enter some content to render...</em></p>';
      return;
    }

    // Process markdown to HTML
    const html = processor.process(markdown);
    output.innerHTML = html;

    // Re-render MathJax for new content
    if (window.MathJax) {
      MathJax.typesetPromise([output]).catch(function (err) {
        console.error('MathJax error:', err);
      });
    }
  });

  // Allow Ctrl+Enter to render
  input.addEventListener('keydown', function(e) {
    if (e.ctrlKey && e.key === 'Enter') {
      button.click();
    }
  });
});
</script>

</body>
</html>
